# 了解 Go 中的数据类型

## 介绍

数据类型指定在编写程序时特定变量将存储的值的类型。数据类型还决定了可以对数据执行哪些操作。

在本文中，我们将回顾 Go 原生的重要数据类型。这并不是对数据类型的详尽调查，但将帮助您熟悉 Go 中可用的选项。了解一些基本数据类型将使您能够编写更清晰且高效执行的代码。

## 背景

考虑数据类型的一种方法是考虑我们在现实世界中使用的不同类型的数据。现实世界中数据的一个例子是数字：例如，我们可以使用整数 (0, 1, 2, …)、整数 (…, -1, 0, 1, …) 和无理数 (π)。

通常，在数学中，我们可以组合不同类型的数字，并得到某种答案。我们可能想将 π 加 5，例如：

```go
5 + π
```

我们可以保留方程作为解决无理数的答案，也可以将 π 四舍五入为小数位数缩写的数字，然后将这些数字相加：

```go
5 + π = 5 + 3.14 = 8.14 
```

但是，如果我们开始尝试用另一种数据类型（例如单词）来评估数字，事情就开始变得没有意义了。我们如何求解以下方程？

```go
shark + 8
```

对于计算机来说，每种数据类型都有很大不同，例如单词和数字。因此，我们必须小心如何使用不同的数据类型来分配值以及如何通过操作来操纵它们。

## 整数

与数学一样，计算机编程中的_整数_是整数，可以是正数、负数或 0 (…, -1, 0, 1, …)。在 Go 中，整数称为`int`。与其他编程语言一样，您不应在四位数或更多数字中使用逗号，因此当您在程序中写入 1,000 时，请将其写为`1000`.

我们可以像这样简单地打印出一个整数：

```go
fmt.Println(-459)
```

```go
Output -459
```

或者，我们可以声明一个变量，在本例中它是我们正在使用或操作的数字的符号，如下所示：

```go
var absoluteZero int = -459
fmt.Println(absoluteZero)
```

```go
Output -459
```

我们也可以在 Go 中使用整数进行数学运算。在下面的代码块中，我们将使用`:=`赋值运算符来声明和实例化变量`sum`：

```go
sum := 116 - 68
fmt.Println(sum)
```

```go
Output 48
```

如输出所示，数学运算符从 中`-`减去整数，得到。您将在**声明变量的数据类型**部分了解有关变量声明的更多信息。`68``116``48`

整数可以在 Go 程序中以多种方式使用。当您继续学习 Go 时，您将有很多机会使用整数并加深对此数据类型的了解。

## 浮点数字

浮点数或_浮点数_用于表示无法表示为整数的_实_[_数。_](https://en.wikipedia.org/wiki/Real_number)实数包括所有有理数和无理数，因此浮点数可以包含小数部分，例如 9.0 或 -116.42。为了考虑 Go 程序中的浮点数，它是一个包含小数点的数字。[](https://en.wikipedia.org/wiki/Real_number)

就像我们对整数所做的那样，我们可以通过简单的方式打印出浮点数，如下所示：

```go
fmt.Println(-459.67)
```

```go
Output -459.67
```

我们还可以声明一个代表浮点数的变量，如下所示：

```go
absoluteZero := -459.67
fmt.Println(absoluteZero)
```

```go
Output -459.67
```

就像整数一样，我们也可以在 Go 中使用浮点数进行数学运算：

```go
var sum = 564.0 + 365.24
fmt.Println(sum)
```

```go
Output 929.24
```

对于整数和浮点数，请务必记住 3 ≠ 3.0，因为 3 指整数，而 3.0 指浮点数。

## 数字类型的大小

除了整数和浮点数之间的区别之外，Go 还有两种类型的数值数据，它们通过其大小的静态或动态性质来区分。第一种类型是_与体系结构无关的_类型，这意味着无论代码运行在什么机器上，数据的大小（以位为单位）都不会改变。

如今大多数系统架构都是 32 位或 64 位。例如，您可能正在为现代 Windows 笔记本电脑进行开发，其操作系统在 64 位架构上运行。但是，如果您正在为健身手表等设备进行开发，则可能会使用 32 位架构。如果您使用与体系结构无关的类型`int32`，例如 ，则无论您编译的体系结构如何，该类型都将具有恒定的大小。

第二种类型是_特定于实现的_类型。在这种类型中，位大小可以根据程序所基于的体系结构而变化。例如，如果我们使用`int`类型，当 Go 编译为 32 位架构时，数据类型的大小将为 32 位。如果程序是针对 64 位体系结构编译的，则变量的大小将为 64 位。

除了具有不同大小的数据类型之外，整数等类型也有两种基本类型：_有符号_和_无符号_。An`int8`是有符号整数，其值可以是 -128 到 127。A`uint8`是无符号整数，只能是 0 到 255 之间的正值。

范围基于位大小。对于二进制数据，8 位总共可以表示 256 个不同的值。由于`int`类型需要支持正值和负值，因此 8 位整数 ( `int8`) 的范围为 -128 到 127，总共有 256 个唯一的可能值。

Go 具有以下与架构无关的整数类型：

```go
uint8       unsigned  8-bit integers (0 to 255)
uint16      unsigned 16-bit integers (0 to 65535)
uint32      unsigned 32-bit integers (0 to 4294967295)
uint64      unsigned 64-bit integers (0 to 18446744073709551615)
int8        signed  8-bit integers (-128 to 127)
int16       signed 16-bit integers (-32768 to 32767)
int32       signed 32-bit integers (-2147483648 to 2147483647)
int64       signed 64-bit integers (-9223372036854775808 to 9223372036854775807)
```

浮点数和复数也有不同的大小：

```go
float32     IEEE-754 32-bit floating-point numbers
float64     IEEE-754 64-bit floating-point numbers
complex64   complex numbers with float32 real and imaginary parts
complex128  complex numbers with float64 real and imaginary parts
```

还有一些别名数字类型，它们为特定数据类型分配有用的名称：

```go
byte        alias for uint8
rune        alias for int32
```

别名的目的`byte`是明确您的程序何时使用字节作为字符串元素中的常见计算测量，而不是与字节数据测量无关的小整数。尽管在程序编译后`byte`和是相同的，但通常用于以数字形式表示字符数据，而是程序中的数字。`uint8``byte``uint8`

别名`rune`有点不同。其中`byte`和`uint8`是完全相同的数据，a`rune`可以是单字节或四个字节，范围由 确定`int32`。A`rune`用于表示 Unicode 字符，而只有 ASCII 字符才能单独由`int32`数据类型表示。

此外，Go 还有以下特定于实现的类型：

```go
uint     unsigned, either 32 or 64 bits
int      signed, either 32 or 64 bits
uintptr  unsigned integer large enough to store the uninterpreted bits of a pointer value 
```

特定于实现的类型的大小将由程序编译所针对的体系结构定义。

### 选择数字数据类型

选择正确的大小通常更多地与您正在编程的目标架构的性能有关，而不是与您正在使用的数据的大小有关。但是，无需了解程序性能的具体影响，您可以在刚开始时遵循其中一些基本准则。

正如本文前面所讨论的，存在与体系结构无关的类型和特定于实现的类型。对于整数数据，Go 中通常使用`int`or等​​实现类型`uint`来代替`int64`or `uint64`。这通常会为您的目标架构带来最快的处理速度。例如，如果您使用`int64`并编译为 32 位体系结构，则处理这些值所需的时间至少是在体系结构中移动数据所需的额外 CPU 周期的两倍。如果您使用 an`int`相反，程序会将其定义为 32 位体系结构的 32 位大小，并且处理速度会显着加快。

如果您知道不会超出特定的大小范围，那么选择独立于体系结构的类型既可以提高速度，又可以减少内存使用量。例如，如果您知道您的数据不会超过 的值`100`，并且只会是一个正数，那么选择 a`uint8`将使您的程序更加高效，因为它需要更少的内存。

现在我们已经了解了数字数据类型的一些可能的范围，让我们看看如果我们在程序中超出这些范围会发生什么。

### 溢出与环绕

当您尝试存储大于数据类型设计存储的值时，Go 可能会_溢出_数字并_环绕数字，具体取决于该值是在编译时还是在运行时计算。_当程序在尝试构建程序时发现错误时，就会发生编译时错误。运行时错误发生在程序编译后、实际执行时。

在下面的示例中，我们设置`maxUint32`为其最大值：

```go
package main

import "fmt"

func main() {
 var maxUint32 uint32 = 4294967295 // Max uint32 size
 fmt.Println(maxUint32)
}
```

它将编译并运行，结果如下：

```go
Output 4294967295
```

如果我们`1`在运行时添加该值，它将环绕为`0`：

```go
Output 0
```

另一方面，让我们更改程序以`1`在编译之前分配变量时添加到变量中：

```go
package main

import "fmt"

func main() {
 var maxUint32 uint32 = 4294967295 + 1
 fmt.Println(maxUint32)

}
```

在编译时，如果编译器可以确定某个值太大而无法容纳指定的数据类型，则会抛出错误`overflow`。这意味着计算的值对于您指定的数据类型来说太大。

因为编译器可以确定它将溢出该值，所以它现在会抛出错误：

```go
Outputprog.go:6:36: constant 4294967296 overflows uint32
```

了解数据的边界将帮助您避免未来程序中潜在的错误。

现在我们已经介绍了数字类型，让我们看看如何存储布尔值。

## 布尔值

布尔数据类型可以是两个值之一，或者或，并且在将其声明为数据类型时_定义_。布尔值用于表示与数学逻辑分支相关的真值，为计算机科学中的算法提供信息。`true``false``bool`

值`true`和`false`始终分别为小写的`t`和`f`，因为它们是 Go 中预先声明的标识符。

数学中的许多运算给我们的答案要么是真要么是假：

- greater than
    - 500 > 100 true
    - 1 > 5 false
- less than
    - 200 < 400 true
    - 4 < 2 false
- equal
    - 5 = 5 true
    - 500 = 400 false

与数字一样，我们可以在变量中存储布尔值：

```go
myBool := 5 > 8
```

然后我们可以通过调用该函数来打印布尔值`fmt.Println()`：

```go
fmt.Println(myBool)
```

由于`5`不大于`8`，我们将收到以下输出：

```go
Output false
```

当您用 Go 编写更多程序时，您将更加熟悉布尔值的工作原理，以及不同的函数和运算对`true`or 的`false`求值如何改变程序的进程。

##

字符串是一个或多个字符（字母、数字、符号）的序列，可以是常量或变量。在 Go 中，字符串存在于反引号`` ` `` 或双引号内`"`，并且根据您使用的引号而具有不同的特征。

如果使用反引号，则将创建_原始_字符串文字。如果使用双引号，则将创建_解释的_字符串文字。

### 原始字符串文字

原始字符串文字是反引号之间的字符序列，通常称为反引号。在引号内，任何字符都将按照在反引号之间显示的方式显示，但反引号字符本身除外。

```go
a := `Say "hello" to Go!`
fmt.Println(a)
```

```go
OutputSay "hello" to Go!
```

通常，反斜杠用于表示字符串中的特殊字符。例如，在解释的字符串中，`\n`将表示字符串中的新行。但是，反斜杠在原始字符串文字中没有特殊含义：

```go
a := `Say "hello" to Go!\n`
fmt.Println(a)
```

因为反斜杠在字符串中没有特殊含义，所以它实际上会打印出 的值，`\n`而不是创建一个新行：

```go
OutputSay "hello" to Go!\n
```

原始字符串文字也可用于创建多行字符串：

```go
a := `This string is on 
multiple lines
within a single back 
quote on either side.`
fmt.Println(a)
```

```go
OutputThis string is on 
multiple lines
within a single back 
quote on either side.
```

在前面的代码块中，新行按字面意思从输入转移到输出。

### 解释的字符串文字

解释的字符串文字是双引号之间的字符序列，如 中`"bar"`。引号内可以出现除换行符和未转义双引号之外的任何字符。要在解释的字符串中显示双引号，可以使用反斜杠作为转义字符，如下所示：

```go
a := "Say \"hello\" to Go!"
fmt.Println(a)
```

```go
OutputSay "hello" to Go!
```

您几乎总是使用解释的字符串文字，因为它们允许在其中使用转义字符。有关使用字符串的更多信息，请查看[Go 中使用字符串简介](https://www.digitalocean.com/community/tutorials/an-introduction-to-working-with-strings-in-go)。

### 带有 UTF-8 字符的字符串

UTF-8 是一种编码方案，用于将可变宽度字符编码为一到四个字节。Go 开箱即用地支持 UTF-8 字符，无需任何特殊设置、库或包。罗马字符（例如字母）`A`可以用 ASCII 值（例如数字 65）表示。但是，对于特殊字符（例如国际字符 ）`世`，则需要 UTF-8。Go 对 UTF-8 数据使用`rune`别名类型。

```go
a := "Hello, 世界"
```

`range`您可以在循环中使用关键字`for`来索引 Go 中的任何字符串，甚至是 UTF-8 字符串。`for`循环，`range`并将在本系列后面更深入地介绍；现在，重要的是要知道我们可以使用它来计算给定字符串中的字节数：

```go
package main

import "fmt"

func main() {
 a := "Hello, 世界"
 for i, c := range a {
  fmt.Printf("%d: %s\n", i, string(c))
 }
 fmt.Println("length of 'Hello, 世界': ", len(a))
}
```

在上面的代码块中，我们声明了变量`a`并为其赋值`Hello, 世界`。分配的文本中包含 UTF-8 字符。

然后我们使用标准`for`循环以及`range`关键字。在 Go 中，`range`关键字将通过一次返回一个字符的字符串进行索引，以及该字符在字符串中所在的字节索引。

使用该`fmt.Printf`函数，我们提供了一个格式字符串`%d: %s\n`。`%d`是数字（在本例中为整数）的打印动词，`%s`是字符串的打印动词。然后，我们提供 的值`i`（循环的当前索引）`for`和的值`c`（循环中的当前字符）`for`。

`a`最后，我们使用内置函数打印了变量的整个长度`len`。

之前，我们提到符文是 的别名`int32`，可以由一到四个字节组成。该`世`字符需要三个字节来定义，并且索引在 UTF-8 字符串范围内相应移动。`i`这就是打印出来时不连续的原因。

```go
Output0: H
1: e
2: l
3: l
4: o
5: ,
6:
7: 世
10: 界
length of 'Hello, 世界':  13
```

正如您所看到的，长度比遍历字符串所需的次数要长。

您不会总是使用 UTF-8 字符串，但是当您使用时，您现在就会明白为什么它们是符文而不是单个`int32`.

## 声明变量的数据类型

现在您已经了解了不同的原始数据类型，我们将介绍如何将这些类型分配给 Go 中的变量。

在 Go 中，我们可以使用关键字定义变量，`var`后跟变量名称和所需的数据类型。

在下面的示例中，我们将声明一个名为`pi`类型的变量`float64`。

关键字`var`是声明的第一个东西：

```go
var pi float64
```

接下来是变量的名称`pi`：

```go
var pi float64
```

最后是数据类型`float64`：

```go
var pi float64
```

我们也可以选择指定一个初始值，例如`3.14`：

```go
var pi float64 = 3.14
```

Go 是一种_静态类型_语言。静态类型意味着程序中的每条语句都会在编译时进行检查。它还意味着数据类型绑定到变量，而在动态链接语言中，数据类型绑定到值。

例如，在Go中，声明变量时声明类型：

```go
var pi float64 = 3.14
var week int = 7
```

如果您以不同方式声明这些变量，则它们中的每一个都可能是不同的数据类型。

这与 PHP 等语言不同，其中数据类型与值相关联：

```go
$s = "sammy";         // $s is automatically a string
$s = 123;             // $s is automatically an integer
```

在前面的代码块中，第一个`$s`是字符串，因为它被分配了值`"sammy"`，第二个是整数，因为它具有值`123`。

接下来，让我们看看更复杂的数据类型，例如数组。

## map(数组)

数组是_元素_的有序序列。数组的容量是在创建时定义的。一旦数组分配了其大小，就无法再更改其大小。因为数组的大小是静态的，这意味着它只分配一次内存。这使得数组的使用有些僵化，但提高了程序的性能。因此，在优化程序时通常使用数组。_接下来介绍的切片_更加灵活，并且构成了您所认为的其他语言中的数组。

数组是通过声明数组的大小，然后声明数据类型以及在大括号之间定义的值来定义的`{ }`。

字符串数组如下所示：

```go
[3]string{"blue coral", "staghorn coral", "pillar coral"}
```

我们可以将数组存储在变量中并将其打印出来：

```go
coral := [3]string{"blue coral", "staghorn coral", "pillar coral"}
fmt.Println(coral)
```

```go
Output[blue coral staghorn coral pillar coral]
```

如前所述，切片与数组类似，但更加灵活。让我们看一下这个可变数据类型。

## slice(切片)

切片是长度可以改变的有序_元素_序列。切片可以动态增加其大小。当您向切片添加新项目时，如果切片没有足够的内存来存储新项目，它将根据需要向系统请求更多内存。由于切片可以在需要时扩展以添加更多元素，因此它们比数组更常用。

切片是通过在左方括号和右方括号之前声明数据类型`[]`并在大括号之间包含值来定义的`{ }` 。

整数切片如下所示：

```go
[]int{-3, -2, -1, 0, 1, 2, 3}
```

一片浮动看起来像这样：

```go
[]float64{3.14, 9.23, 111.11, 312.12, 1.05}
```

一段字符串看起来像这样：

```go
[]string{"shark", "cuttlefish", "squid", "mantis shrimp"}
```

让我们将字符串切片定义为`seaCreatures`：

```go
seaCreatures := []string{"shark", "cuttlefish", "squid", "mantis shrimp"}
```

我们可以通过调用变量来打印它们：

```go
fmt.Println(seaCreatures)
```

输出将与我们创建的列表完全相同：

```go
Output[shark cuttlefish squid mantis shrimp]
```

我们可以使用`append`关键字将项目添加到我们的切片中。以下命令会将 的字符串值添加`seahorse`到切片中：

```go
seaCreatures = append(seaCreatures, "seahorse")
```

您可以通过打印来验证它是否已添加：

```go
fmt.Println(seaCreatures)
```

```go
Output[shark cuttlefish squid mantis shrimp seahorse]
```

正如您所看到的，如果您需要管理未知大小的元素，切片将比数组更通用。

## hash map(字典或哈希)

映射是 Go 内置的哈希或字典类型_。_映射使用_键_和_值_作为一对来存储数据。这对于通过索引（或者在本例中是键）快速查找值的编程很有用。例如，您可能想要保留用户地图，并按用户 ID 建立索引。键是用户 ID，用户对象是值。映射是通过使用关键字、`map`方括号中的键数据类型`[ ]`、大括号中的值数据类型和键值对来构造的。

```go
map[key]value{}
```

映射通常用于保存相关数据，例如 ID 中包含的信息，如下所示：

```go
map[string]string{"name": "Sammy", "animal": "shark", "color": "blue", "location": "ocean"}
```

您会注意到，除了大括号之外，整个地图中还有冒号。冒号左边的单词是键。键可以是 Go 中任何_类似的_类型。可比较类型是原始类型，例如`strings`、`ints`等。原始类型由语言定义，而不是通过组合任何其他类型构建的。虽然它们可以是用户定义的类型，但最好的做法是保持它们简单以避免编程错误。上面字典中的键是：`name`、`animal`、`color`和`location`。

冒号右侧的单词是值。值可以由任何数据类型组成。上面字典中的值是：`Sammy`、`shark`、`blue`和`ocean`。

让我们将地图存储在变量中并将其打印出来：

```go
sammy := map[string]string{"name": "Sammy", "animal": "shark", "color": "blue", "location": "ocean"}
fmt.Println(sammy)
```

```go
Outputmap[animal:shark color:blue location:ocean name:Sammy]
```

如果我们想隔离 Sammy 的颜色，我们可以通过调用 来实现`sammy["color"]`。让我们打印出来：

```go
fmt.Println(sammy["color"])
```

```
Outputblue
```

由于映射提供用于存储数据的键值对，因此它们可能是 Go 程序中的重要元素。

## 结论

至此，您应该对 Go 中可以使用的一些主要数据类型有了更好的了解。当您使用 Go 语言开发编程项目时，这些数据类型中的每一种都将变得很重要。

一旦您牢固掌握了 Go 中可用的数据类型，您就可以学习[如何转换数据类型](https://www.digitalocean.com/community/tutorials/how-to-convert-data-types-in-go)，以便根据情况更改数据类型。
